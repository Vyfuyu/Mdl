
const { createCanvas, loadImage, registerFont } = require('canvas');
const fs = require('fs-extra');
const axios = require('axios');

module.exports.config = {
    name: "xocdia",
    version: "2.0.0",
    hasPermssion: 0,
    credits: "Kaori Waguri",
    description: "üé∞ Game x√≥c ƒëƒ©a VIP v·ªõi nhi·ªÅu t√≠nh nƒÉng ƒë·∫∑c bi·ªát v√† giao di·ªán canvas ƒë·∫πp m·∫Øt!",
    commandCategory: "GAME VIP",
    usages: "[t√†i/x·ªâu/l·∫ª/ch·∫µn] [s·ªë ti·ªÅn] ho·∫∑c [create/join/start/info/leave]",
    cooldowns: 3,
    dependencies: {
        "canvas": "",
        "axios": ""
    }
};

module.exports.onLoad = async function() {
    // T·∫°o th∆∞ m·ª•c cache n·∫øu ch∆∞a c√≥
    const cacheDir = __dirname + '/cache';
    if (!fs.existsSync(cacheDir)) {
        fs.mkdirSync(cacheDir, { recursive: true });
    }
    
    // T·∫£i font ch·ªØ ƒë·∫πp
    try {
        const fontPath = __dirname + '/cache/font.ttf';
        if (!fs.existsSync(fontPath)) {
            const fontResponse = await axios.get('https://github.com/googlefonts/roboto/raw/main/src/hinted/Roboto-Bold.ttf', {
                responseType: 'arraybuffer'
            });
            fs.writeFileSync(fontPath, fontResponse.data);
        }
        registerFont(fontPath, { family: 'Roboto' });
    } catch (error) {
        console.log('Font loading error:', error.message);
    }
    
    console.log("üé∞ XOC DIA VIP GAME LOADED SUCCESSFULLY! üé∞");
};

// H√†m t·∫°o canvas cho k·∫øt qu·∫£ x√≥c ƒëƒ©a
async function createXocDiaCanvas(result, coins, isWin, betAmount, winAmount) {
    const canvas = createCanvas(800, 600);
    const ctx = canvas.getContext('2d');
    
    // Gradient background
    const gradient = ctx.createLinearGradient(0, 0, 800, 600);
    gradient.addColorStop(0, '#1a1a2e');
    gradient.addColorStop(0.5, '#16213e');
    gradient.addColorStop(1, '#0f3460');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 800, 600);
    
    // V·∫Ω khung vi·ªÅn ƒë·∫πp
    ctx.strokeStyle = '#ffd700';
    ctx.lineWidth = 8;
    ctx.setLineDash([20, 10]);
    ctx.strokeRect(20, 20, 760, 560);
    ctx.setLineDash([]);
    
    // Title
    ctx.font = 'bold 48px Roboto, Arial';
    ctx.fillStyle = '#ffd700';
    ctx.textAlign = 'center';
    ctx.fillText('üé∞ X√ìC ƒêƒ®A VIP üé∞', 400, 80);
    
    // V·∫Ω ƒëƒ©a x√≥c
    const centerX = 400;
    const centerY = 250;
    const plateRadius = 120;
    
    // ƒêƒ©a ch√≠nh
    const plateGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, plateRadius);
    plateGradient.addColorStop(0, '#8b4513');
    plateGradient.addColorStop(1, '#654321');
    ctx.fillStyle = plateGradient;
    ctx.beginPath();
    ctx.arc(centerX, centerY, plateRadius, 0, 2 * Math.PI);
    ctx.fill();
    ctx.strokeStyle = '#ffd700';
    ctx.lineWidth = 4;
    ctx.stroke();
    
    // V·∫Ω 4 xu
    const coinPositions = [
        { x: centerX - 40, y: centerY - 40 },
        { x: centerX + 40, y: centerY - 40 },
        { x: centerX - 40, y: centerY + 40 },
        { x: centerX + 40, y: centerY + 40 }
    ];
    
    for (let i = 0; i < 4; i++) {
        const pos = coinPositions[i];
        const coinResult = coins[i];
        
        // B√≥ng ƒë·ªï
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.arc(pos.x + 2, pos.y + 2, 25, 0, 2 * Math.PI);
        ctx.fill();
        
        // Xu
        const coinGradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, 25);
        if (coinResult === 's·∫•p') {
            coinGradient.addColorStop(0, '#ffd700');
            coinGradient.addColorStop(1, '#ffb347');
        } else {
            coinGradient.addColorStop(0, '#c0c0c0');
            coinGradient.addColorStop(1, '#808080');
        }
        ctx.fillStyle = coinGradient;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 25, 0, 2 * Math.PI);
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Text tr√™n xu
        ctx.font = 'bold 12px Roboto, Arial';
        ctx.fillStyle = coinResult === 's·∫•p' ? '#000' : '#fff';
        ctx.textAlign = 'center';
        ctx.fillText(coinResult === 's·∫•p' ? 'S·∫§P' : 'NG·ª¨A', pos.x, pos.y + 4);
    }
    
    // K·∫øt qu·∫£
    ctx.font = 'bold 36px Roboto, Arial';
    ctx.fillStyle = isWin ? '#00ff00' : '#ff4757';
    ctx.textAlign = 'center';
    ctx.fillText(`K·∫æT QU·∫¢: ${result.toUpperCase()}`, 400, 400);
    
    // Th√¥ng tin c∆∞·ª£c
    ctx.font = 'bold 24px Roboto, Arial';
    ctx.fillStyle = '#fff';
    ctx.fillText(`Ti·ªÅn c∆∞·ª£c: ${betAmount.toLocaleString()}$`, 400, 450);
    
    if (isWin) {
        ctx.fillStyle = '#00ff00';
        ctx.fillText(`üéâ TH·∫ÆNG: +${winAmount.toLocaleString()}$ üéâ`, 400, 480);
    } else {
        ctx.fillStyle = '#ff4757';
        ctx.fillText(`üí∏ THUA: -${betAmount.toLocaleString()}$ üí∏`, 400, 480);
    }
    
    // Th·ªëng k√™
    const sapCount = coins.filter(c => c === 's·∫•p').length;
    const nguaCount = 4 - sapCount;
    
    ctx.font = 'bold 20px Roboto, Arial';
    ctx.fillStyle = '#ffd700';
    ctx.fillText(`S·∫•p: ${sapCount} | Ng·ª≠a: ${nguaCount}`, 400, 520);
    
    return canvas.toBuffer();
}

// H√†m t·∫°o b√†n ch∆°i nh√≥m
function createGameRoom(threadID, authorID, betAmount) {
    if (!global.moduleData.xocdia) global.moduleData.xocdia = new Map();
    
    global.moduleData.xocdia.set(threadID, {
        author: authorID,
        betAmount: betAmount,
        players: [{ id: authorID, bet: null }],
        status: "waiting", // waiting, playing, finished
        startTime: Date.now(),
        round: 1
    });
}

module.exports.run = async function({ api, event, args, Currencies, Users }) {
    const { senderID, threadID, messageID } = event;
    
    if (!global.moduleData.xocdia) global.moduleData.xocdia = new Map();
    
    // L·ªánh qu·∫£n l√Ω ph√≤ng ch∆°i
    if (["create", "t·∫°o"].includes(args[0]?.toLowerCase())) {
        if (global.moduleData.xocdia.has(threadID)) {
            return api.sendMessage("‚ö†Ô∏è ƒê√£ c√≥ ph√≤ng x√≥c ƒëƒ©a trong nh√≥m n√†y r·ªìi!", threadID, messageID);
        }
        
        const betAmount = parseInt(args[1]);
        if (!betAmount || betAmount < 1000) {
            return api.sendMessage("üí∞ Vui l√≤ng nh·∫≠p s·ªë ti·ªÅn c∆∞·ª£c t·ªëi thi·ªÉu 1000$\nüìù C√°ch d√πng: xocdia create [s·ªë ti·ªÅn]", threadID, messageID);
        }
        
        const userData = await Currencies.getData(senderID);
        if (userData.money < betAmount) {
            return api.sendMessage("üí∏ B·∫°n kh√¥ng ƒë·ªß ti·ªÅn ƒë·ªÉ t·∫°o ph√≤ng!", threadID, messageID);
        }
        
        createGameRoom(threadID, senderID, betAmount);
        await Currencies.decreaseMoney(senderID, betAmount);
        
        const setupMessage = `üé∞ PH√íNG X√ìC ƒêƒ®A VIP ƒê√É M·ªû üé∞

üëë Ch·ªß ph√≤ng: ${await Users.getNameUser(senderID)}
üí∞ Ti·ªÅn c∆∞·ª£c: ${betAmount.toLocaleString()}$
üë• S·ªë ng∆∞·ªùi ch∆°i: 1/8
‚è∞ Th·ªùi gian: ${new Date().toLocaleString()}

üéØ C√ÅCH CH∆†I:
‚Ä¢ xocdia join - Tham gia ph√≤ng
‚Ä¢ xocdia start - B·∫Øt ƒë·∫ßu game (ch·ªß ph√≤ng)
‚Ä¢ xocdia info - Xem th√¥ng tin ph√≤ng
‚Ä¢ xocdia leave - R·ªùi ph√≤ng

üé≤ C√ÅC LO·∫†I C∆Ø·ª¢C:
‚Ä¢ T√†i (3-4 s·∫•p) | X·ªâu (0-1 s·∫•p)
‚Ä¢ Ch·∫µn (0,2,4 s·∫•p) | L·∫ª (1,3 s·∫•p)

üìä T·ª∂ L·ªÜ TH·∫ÆNG: x2 ti·ªÅn c∆∞·ª£c`;
        
        return api.sendMessage(setupMessage, threadID, messageID);
    }
    
    if (["join", "tham gia"].includes(args[0]?.toLowerCase())) {
        const gameData = global.moduleData.xocdia.get(threadID);
        if (!gameData) {
            return api.sendMessage("‚ùå Ch∆∞a c√≥ ph√≤ng x√≥c ƒëƒ©a n√†o! D√πng 'xocdia create [s·ªë ti·ªÅn]' ƒë·ªÉ t·∫°o ph√≤ng", threadID, messageID);
        }
        
        if (gameData.players.find(p => p.id === senderID)) {
            return api.sendMessage("‚ö†Ô∏è B·∫°n ƒë√£ tham gia ph√≤ng n√†y r·ªìi!", threadID, messageID);
        }
        
        if (gameData.players.length >= 8) {
            return api.sendMessage("üö´ Ph√≤ng ƒë√£ ƒë·∫ßy (8/8 ng∆∞·ªùi ch∆°i)", threadID, messageID);
        }
        
        const userData = await Currencies.getData(senderID);
        if (userData.money < gameData.betAmount) {
            return api.sendMessage("üí∏ B·∫°n kh√¥ng ƒë·ªß ti·ªÅn ƒë·ªÉ tham gia ph√≤ng!", threadID, messageID);
        }
        
        gameData.players.push({ id: senderID, bet: null });
        await Currencies.decreaseMoney(senderID, gameData.betAmount);
        
        return api.sendMessage(`‚úÖ ${await Users.getNameUser(senderID)} ƒë√£ tham gia ph√≤ng!\nüë• S·ªë ng∆∞·ªùi ch∆°i: ${gameData.players.length}/8`, threadID, messageID);
    }
    
    if (["start", "b·∫Øt ƒë·∫ßu"].includes(args[0]?.toLowerCase())) {
        const gameData = global.moduleData.xocdia.get(threadID);
        if (!gameData) {
            return api.sendMessage("‚ùå Ch∆∞a c√≥ ph√≤ng x√≥c ƒëƒ©a n√†o!", threadID, messageID);
        }
        
        if (gameData.author !== senderID) {
            return api.sendMessage("üö´ Ch·ªâ ch·ªß ph√≤ng m·ªõi c√≥ th·ªÉ b·∫Øt ƒë·∫ßu game!", threadID, messageID);
        }
        
        if (gameData.players.length < 2) {
            return api.sendMessage("‚ö†Ô∏è C·∫ßn √≠t nh·∫•t 2 ng∆∞·ªùi ch∆°i ƒë·ªÉ b·∫Øt ƒë·∫ßu!", threadID, messageID);
        }
        
        gameData.status = "playing";
        
        return api.sendMessage(`üé∞ GAME B·∫ÆT ƒê·∫¶U! üé∞

üë• S·ªë ng∆∞·ªùi ch∆°i: ${gameData.players.length}
üí∞ T·ªïng ti·ªÅn th∆∞·ªüng: ${(gameData.betAmount * gameData.players.length).toLocaleString()}$

üéØ H√ÉY ƒê·∫∂T C∆Ø·ª¢C:
‚Ä¢ xocdia t√†i [s·ªë ti·ªÅn b·ªï sung]
‚Ä¢ xocdia x·ªâu [s·ªë ti·ªÅn b·ªï sung] 
‚Ä¢ xocdia ch·∫µn [s·ªë ti·ªÅn b·ªï sung]
‚Ä¢ xocdia l·∫ª [s·ªë ti·ªÅn b·ªï sung]

‚è±Ô∏è Th·ªùi gian ƒë·∫∑t c∆∞·ª£c: 60 gi√¢y`, threadID, messageID);
    }
    
    // ƒê·∫∑t c∆∞·ª£c c√° nh√¢n (kh√¥ng c·∫ßn ph√≤ng)
    const betTypes = ["t√†i", "x·ªâu", "ch·∫µn", "l·∫ª"];
    const betType = args[0]?.toLowerCase();
    
    if (betTypes.includes(betType)) {
        const betAmount = parseInt(args[1]) || 0;
        
        if (betAmount < 1000) {
            return api.sendMessage("üí∞ S·ªë ti·ªÅn c∆∞·ª£c t·ªëi thi·ªÉu l√† 1000$!", threadID, messageID);
        }
        
        const userData = await Currencies.getData(senderID);
        if (userData.money < betAmount) {
            return api.sendMessage("üí∏ B·∫°n kh√¥ng ƒë·ªß ti·ªÅn ƒë·ªÉ ƒë·∫∑t c∆∞·ª£c!", threadID, messageID);
        }
        
        // T·∫°o k·∫øt qu·∫£ x√≥c ƒëƒ©a
        const coins = [];
        for (let i = 0; i < 4; i++) {
            coins.push(Math.random() < 0.5 ? 's·∫•p' : 'ng·ª≠a');
        }
        
        const sapCount = coins.filter(c => c === 's·∫•p').length;
        let result, isWin = false;
        
        // X√°c ƒë·ªãnh k·∫øt qu·∫£
        if (betType === "t√†i" && sapCount >= 3) {
            result = `t√†i (${sapCount} s·∫•p)`;
            isWin = true;
        } else if (betType === "x·ªâu" && sapCount <= 1) {
            result = `x·ªâu (${sapCount} s·∫•p)`;
            isWin = true;
        } else if (betType === "ch·∫µn" && sapCount % 2 === 0) {
            result = `ch·∫µn (${sapCount} s·∫•p)`;
            isWin = true;
        } else if (betType === "l·∫ª" && sapCount % 2 === 1) {
            result = `l·∫ª (${sapCount} s·∫•p)`;
            isWin = true;
        } else {
            result = `${sapCount >= 3 ? 't√†i' : sapCount <= 1 ? 'x·ªâu' : sapCount % 2 === 0 ? 'ch·∫µn' : 'l·∫ª'} (${sapCount} s·∫•p)`;
        }
        
        const winAmount = isWin ? betAmount * 2 : 0;
        
        // C·∫≠p nh·∫≠t ti·ªÅn
        if (isWin) {
            await Currencies.increaseMoney(senderID, winAmount);
        } else {
            await Currencies.decreaseMoney(senderID, betAmount);
        }
        
        // T·∫°o canvas
        try {
            const canvasBuffer = await createXocDiaCanvas(result, coins, isWin, betAmount, winAmount);
            const imagePath = __dirname + `/cache/xocdia_${senderID}_${Date.now()}.png`;
            fs.writeFileSync(imagePath, canvasBuffer);
            
            const userName = await Users.getNameUser(senderID);
            const resultMessage = `üé∞ K·∫æT QU·∫¢ X√ìC ƒêƒ®A VIP üé∞

üë§ Ng∆∞·ªùi ch∆°i: ${userName}
üéØ ƒê·∫∑t c∆∞·ª£c: ${betType.toUpperCase()}
üé≤ K·∫øt qu·∫£: ${result.toUpperCase()}
${isWin ? 'üéâ CH√öC M·ª™NG B·ª¨N TH·∫ÆNG!' : 'üò¢ Ch√∫c b·∫°n may m·∫Øn l·∫ßn sau!'}

üí∞ Thay ƒë·ªïi s·ªë d∆∞: ${isWin ? '+' : '-'}${betAmount.toLocaleString()}$
üí≥ S·ªë d∆∞ hi·ªán t·∫°i: ${(userData.money + (isWin ? winAmount : -betAmount)).toLocaleString()}$`;
            
            api.sendMessage({
                body: resultMessage,
                attachment: fs.createReadStream(imagePath)
            }, threadID, () => {
                setTimeout(() => {
                    if (fs.existsSync(imagePath)) {
                        fs.unlinkSync(imagePath);
                    }
                }, 30000);
            }, messageID);
            
        } catch (error) {
            console.log("Canvas error:", error);
            // Fallback message without image
            const fallbackMessage = `üé∞ K·∫æT QU·∫¢ X√ìC ƒêƒ®A üé∞

üéØ B·∫°n c∆∞·ª£c: ${betType.toUpperCase()}
üé≤ K·∫øt qu·∫£: ${result.toUpperCase()}
ü™ô Xu: ${coins.map(c => c === 's·∫•p' ? 'üü°' : '‚ö™').join(' ')}

${isWin ? 'üéâ TH·∫ÆNG: +' + winAmount.toLocaleString() + '$' : 'üí∏ THUA: -' + betAmount.toLocaleString() + '$'}`;
            
            return api.sendMessage(fallbackMessage, threadID, messageID);
        }
        
        return;
    }
    
    // C√°c l·ªánh kh√°c
    if (["info", "th√¥ng tin"].includes(args[0]?.toLowerCase())) {
        const gameData = global.moduleData.xocdia.get(threadID);
        if (!gameData) {
            return api.sendMessage("‚ùå Ch∆∞a c√≥ ph√≤ng x√≥c ƒëƒ©a n√†o!", threadID, messageID);
        }
        
        let playerList = "";
        for (const player of gameData.players) {
            const name = await Users.getNameUser(player.id);
            playerList += `‚Ä¢ ${name}${player.id === gameData.author ? ' (Ch·ªß ph√≤ng)' : ''}\n`;
        }
        
        const infoMessage = `üé∞ TH√îNG TIN PH√íNG X√ìC ƒêƒ®A üé∞

üë• Danh s√°ch ng∆∞·ªùi ch∆°i (${gameData.players.length}/8):
${playerList}
üí∞ Ti·ªÅn c∆∞·ª£c: ${gameData.betAmount.toLocaleString()}$
üèÜ T·ªïng gi·∫£i th∆∞·ªüng: ${(gameData.betAmount * gameData.players.length).toLocaleString()}$
üìä Tr·∫°ng th√°i: ${gameData.status === 'waiting' ? 'ƒêang ch·ªù' : 'ƒêang ch∆°i'}
‚è∞ T·∫°o l√∫c: ${new Date(gameData.startTime).toLocaleString()}`;
        
        return api.sendMessage(infoMessage, threadID, messageID);
    }
    
    if (["leave", "r·ªùi"].includes(args[0]?.toLowerCase())) {
        const gameData = global.moduleData.xocdia.get(threadID);
        if (!gameData) {
            return api.sendMessage("‚ùå Ch∆∞a c√≥ ph√≤ng x√≥c ƒëƒ©a n√†o!", threadID, messageID);
        }
        
        const playerIndex = gameData.players.findIndex(p => p.id === senderID);
        if (playerIndex === -1) {
            return api.sendMessage("‚ö†Ô∏è B·∫°n ch∆∞a tham gia ph√≤ng n√†y!", threadID, messageID);
        }
        
        // Ho√†n ti·ªÅn
        await Currencies.increaseMoney(senderID, gameData.betAmount);
        gameData.players.splice(playerIndex, 1);
        
        if (gameData.author === senderID || gameData.players.length === 0) {
            // Ho√†n ti·ªÅn cho t·∫•t c·∫£
            for (const player of gameData.players) {
                await Currencies.increaseMoney(player.id, gameData.betAmount);
            }
            global.moduleData.xocdia.delete(threadID);
            return api.sendMessage("üö™ Ch·ªß ph√≤ng ƒë√£ r·ªùi, ph√≤ng b·ªã gi·∫£i t√°n!", threadID, messageID);
        }
        
        return api.sendMessage(`üö™ ${await Users.getNameUser(senderID)} ƒë√£ r·ªùi ph√≤ng!`, threadID, messageID);
    }
    
    // H∆∞·ªõng d·∫´n
    const helpMessage = `üé∞ H∆Ø·ªöNG D·∫™N X√ìC ƒêƒ®A VIP üé∞

üéØ L·ªÜNH C√Å NH√ÇN:
‚Ä¢ xocdia t√†i [ti·ªÅn] - C∆∞·ª£c t√†i (3-4 s·∫•p)
‚Ä¢ xocdia x·ªâu [ti·ªÅn] - C∆∞·ª£c x·ªâu (0-1 s·∫•p)  
‚Ä¢ xocdia ch·∫µn [ti·ªÅn] - C∆∞·ª£c ch·∫µn (0,2,4 s·∫•p)
‚Ä¢ xocdia l·∫ª [ti·ªÅn] - C∆∞·ª£c l·∫ª (1,3 s·∫•p)

üè† L·ªÜNH PH√íNG CH∆†I:
‚Ä¢ xocdia create [ti·ªÅn] - T·∫°o ph√≤ng
‚Ä¢ xocdia join - Tham gia ph√≤ng
‚Ä¢ xocdia start - B·∫Øt ƒë·∫ßu (ch·ªß ph√≤ng)
‚Ä¢ xocdia info - Xem th√¥ng tin
‚Ä¢ xocdia leave - R·ªùi ph√≤ng

üí∞ T·ª∑ l·ªá th·∫Øng: x2 ti·ªÅn c∆∞·ª£c
üí∏ C∆∞·ª£c t·ªëi thi·ªÉu: 1000$`;
    
    return api.sendMessage(helpMessage, threadID, messageID);
};
