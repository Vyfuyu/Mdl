
const fs = require('fs');
const axios = require('axios');
const path = require('path');
const { createCanvas, loadImage, registerFont } = require('canvas');

module.exports.config = {
    name: "dechete",
    version: "1.0.0",
    hasPermssion: 0,
    credits: "Kaori Waguri",
    description: "Game ƒê·∫ø Ch·∫ø T√†i Ch√≠nh - X√¢y d·ª±ng ƒë·∫ø ch·∫ø kinh doanh c·ªßa b·∫°n",
    commandCategory: "game",
    usages: "[batdau/trangthai/nangcap/vayngan/trano/bangxephang/dautus/banthuong]",
    cooldowns: 3,
    dependencies: {
        "canvas": "",
        "axios": ""
    }
};

// ƒê∆∞·ªùng d·∫´n l∆∞u d·ªØ li·ªáu
const dataPath = path.join(__dirname, 'cache', 'dechete_data.json');
const companyStatsPath = path.join(__dirname, 'cache', 'company_stats.json');
const globalDataPath = path.join(__dirname, 'cache', 'global_data.json');

// Kh·ªüi t·∫°o d·ªØ li·ªáu
function initData() {
    const dir = path.dirname(dataPath);
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }
    
    if (!fs.existsSync(dataPath)) {
        fs.writeFileSync(dataPath, JSON.stringify({}, null, 2));
    }
    
    if (!fs.existsSync(companyStatsPath)) {
        const companyStats = {
            1: { upgradeCost: 0, dailyPayout: 1000, maintenanceCost: 100 },
            2: { upgradeCost: 10000, dailyPayout: 2500, maintenanceCost: 300 },
            3: { upgradeCost: 50000, dailyPayout: 6000, maintenanceCost: 800 },
            4: { upgradeCost: 200000, dailyPayout: 15000, maintenanceCost: 2000 },
            5: { upgradeCost: 800000, dailyPayout: 35000, maintenanceCost: 5000 },
            6: { upgradeCost: 3000000, dailyPayout: 80000, maintenanceCost: 12000 },
            7: { upgradeCost: 10000000, dailyPayout: 180000, maintenanceCost: 30000 },
            8: { upgradeCost: 40000000, dailyPayout: 400000, maintenanceCost: 75000 },
            9: { upgradeCost: 150000000, dailyPayout: 900000, maintenanceCost: 180000 },
            10: { upgradeCost: 500000000, dailyPayout: 2000000, maintenanceCost: 400000 }
        };
        fs.writeFileSync(companyStatsPath, JSON.stringify(companyStats, null, 2));
    }
    
    if (!fs.existsSync(globalDataPath)) {
        fs.writeFileSync(globalDataPath, JSON.stringify({ companies: [] }, null, 2));
    }
}

// ƒê·ªçc d·ªØ li·ªáu
function readData(filePath) {
    try {
        return JSON.parse(fs.readFileSync(filePath, 'utf8'));
    } catch (error) {
        initData();
        return JSON.parse(fs.readFileSync(filePath, 'utf8'));
    }
}

// L∆∞u d·ªØ li·ªáu
function saveData(filePath, data) {
    fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
}

// Format s·ªë ti·ªÅn
function formatMoney(amount) {
    if (amount >= 1000000000) return (amount / 1000000000).toFixed(1) + 'B';
    if (amount >= 1000000) return (amount / 1000000).toFixed(1) + 'M';
    if (amount >= 1000) return (amount / 1000).toFixed(1) + 'K';
    return amount.toLocaleString('vi-VN');
}

// T·∫°o ·∫£nh canvas
async function createCompanyImage(userData, companyStats) {
    const width = 800;
    const height = 600;
    const canvas = createCanvas(width, height);
    const ctx = canvas.getContext('2d');

    // Background gradient
    const gradient = ctx.createLinearGradient(0, 0, width, height);
    gradient.addColorStop(0, '#1a1a2e');
    gradient.addColorStop(0.5, '#16213e');
    gradient.addColorStop(1, '#0f3460');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);

    // Border
    ctx.strokeStyle = '#00d4ff';
    ctx.lineWidth = 3;
    ctx.strokeRect(10, 10, width-20, height-20);

    // Title
    ctx.fillStyle = '#00d4ff';
    ctx.font = 'bold 36px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('ƒê·∫æ CH·∫æ T√ÄI CH√çNH', width/2, 60);

    // Company name
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 28px Arial';
    ctx.fillText(userData.companyName, width/2, 110);

    // Stats background
    ctx.fillStyle = 'rgba(0, 212, 255, 0.1)';
    ctx.fillRect(50, 140, width-100, 340);
    ctx.strokeStyle = '#00d4ff';
    ctx.lineWidth = 2;
    ctx.strokeRect(50, 140, width-100, 340);

    // Stats
    const stats = [
        { label: 'üè¢ C·∫•p ƒë·ªô:', value: `Level ${userData.companyLevel}` },
        { label: 'üí∞ Ti·ªÅn m·∫∑t:', value: `$${formatMoney(userData.cash)}` },
        { label: 'üí≥ N·ª£:', value: `$${formatMoney(userData.debt)}` },
        { label: 'üíé T√†i s·∫£n th·ª±c:', value: `$${formatMoney(userData.cash - userData.debt)}` },
        { label: '‚ö° Thu nh·∫≠p/5p:', value: `$${formatMoney(companyStats[userData.companyLevel].dailyPayout)}` },
        { label: 'üîß Chi ph√≠ BT/ng√†y:', value: `$${formatMoney(companyStats[userData.companyLevel].maintenanceCost)}` },
        { label: '‚ö†Ô∏è Ch·ªâ s·ªë r·ªßi ro:', value: `${userData.riskFactor}%` },
        { label: '‚è∞ L·∫ßn c·∫≠p nh·∫≠t cu·ªëi:', value: new Date(userData.lastPayout).toLocaleString('vi-VN') }
    ];

    ctx.fillStyle = '#ffffff';
    ctx.font = '22px Arial';
    ctx.textAlign = 'left';
    
    stats.forEach((stat, index) => {
        const y = 180 + (index * 35);
        ctx.fillStyle = '#00d4ff';
        ctx.fillText(stat.label, 80, y);
        ctx.fillStyle = '#ffffff';
        ctx.fillText(stat.value, 300, y);
    });

    // Footer
    ctx.fillStyle = '#00d4ff';
    ctx.font = '16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Credit: Kaori Waguri', width/2, height-30);

    return canvas.toBuffer();
}

// T√≠nh to√°n thu nh·∫≠p th·ª• ƒë·ªông
function calculatePassiveIncome(userData, companyStats) {
    const now = Date.now();
    const lastPayout = userData.lastPayout || now;
    const timeDiff = now - lastPayout;
    const fiveMinutes = 5 * 60 * 1000; // 5 ph√∫t
    
    if (timeDiff >= fiveMinutes) {
        const intervals = Math.floor(timeDiff / fiveMinutes);
        const income = companyStats[userData.companyLevel].dailyPayout * intervals;
        
        // T√≠nh chi ph√≠ b·∫£o tr√¨
        const dailyMaintenance = companyStats[userData.companyLevel].maintenanceCost;
        const daysPassed = Math.floor(timeDiff / (24 * 60 * 60 * 1000));
        const maintenanceCost = dailyMaintenance * daysPassed;
        
        userData.cash += income;
        userData.cash -= maintenanceCost;
        userData.lastPayout = now;
        
        // TƒÉng r·ªßi ro n·∫øu ti·ªÅn √¢m
        if (userData.cash < 0) {
            userData.debt += Math.abs(userData.cash);
            userData.cash = 0;
            userData.riskFactor += 5;
        }
        
        return { income, maintenanceCost, intervals };
    }
    
    return null;
}

// Random events
function checkRandomEvents(userData) {
    const events = [];
    
    // S·ª± ki·ªán r·ªßi ro cao
    if (userData.riskFactor > 50 && Math.random() < 0.3) {
        const loss = Math.floor(userData.cash * 0.2);
        userData.cash -= loss;
        userData.riskFactor += 10;
        events.push(`‚ö†Ô∏è B√ä B·ªêI! C√¥ng ty b·∫°n b·ªã ph·∫°t $${formatMoney(loss)}!`);
    }
    
    // S·ª± ki·ªán may m·∫Øn
    if (userData.riskFactor < 20 && Math.random() < 0.1) {
        const bonus = Math.floor(userData.cash * 0.15);
        userData.cash += bonus;
        events.push(`üçÄ MAY M·∫ÆN! B·∫°n nh·∫≠n ƒë∆∞·ª£c h·ª£p ƒë·ªìng l·ªõn +$${formatMoney(bonus)}!`);
    }
    
    // Ki·ªÉm tra ph√° s·∫£n
    if (userData.debt > userData.cash * 10 && userData.riskFactor > 80) {
        events.push(`üí• PH√Å S·∫¢N! C√¥ng ty b·∫°n ƒë√£ b·ªã thanh l√Ω!`);
        return { events, bankrupt: true };
    }
    
    return { events, bankrupt: false };
}

// C·∫≠p nh·∫≠t b·∫£ng x·∫øp h·∫°ng
function updateLeaderboard(userID, userData) {
    const globalData = readData(globalDataPath);
    const netWorth = userData.cash - userData.debt;
    
    const existingIndex = globalData.companies.findIndex(c => c.userID === userID);
    const companyData = {
        userID,
        companyName: userData.companyName,
        netWorth,
        level: userData.companyLevel
    };
    
    if (existingIndex !== -1) {
        globalData.companies[existingIndex] = companyData;
    } else {
        globalData.companies.push(companyData);
    }
    
    globalData.companies.sort((a, b) => b.netWorth - a.netWorth);
    saveData(globalDataPath, globalData);
}

module.exports.run = async function({ api, event, args, Users }) {
    const { threadID, messageID, senderID } = event;
    const userID = senderID;
    
    initData();
    const userData = readData(dataPath);
    const companyStats = readData(companyStatsPath);
    const action = args[0]?.toLowerCase();
    
    // Auto calculate passive income
    if (userData[userID]) {
        const income = calculatePassiveIncome(userData[userID], companyStats);
        if (income) {
            const events = checkRandomEvents(userData[userID]);
            if (events.bankrupt) {
                delete userData[userID];
                saveData(dataPath, userData);
                return api.sendMessage(`üí• PH√Å S·∫¢N!\n\nC√¥ng ty c·ªßa b·∫°n ƒë√£ b·ªã thanh l√Ω do n·ª£ qu√° nhi·ªÅu v√† r·ªßi ro cao!\n\nH√£y d√πng '!dechete batdau' ƒë·ªÉ b·∫Øt ƒë·∫ßu l·∫°i!`, threadID, messageID);
            }
            saveData(dataPath, userData);
            updateLeaderboard(userID, userData[userID]);
        }
    }
    
    switch (action) {
        case 'batdau':
        case 'start': {
            if (userData[userID]) {
                return api.sendMessage('üè¢ B·∫°n ƒë√£ c√≥ c√¥ng ty r·ªìi! D√πng "!dechete trangthai" ƒë·ªÉ xem tr·∫°ng th√°i.', threadID, messageID);
            }
            
            return api.sendMessage('üè¢ Ch√†o m·ª´ng ƒë·∫øn v·ªõi ƒê·∫ø Ch·∫ø T√†i Ch√≠nh!\n\nH√£y nh·∫≠p t√™n c√¥ng ty c·ªßa b·∫°n:', threadID, (err, info) => {
                global.client.handleReply.push({
                    name: this.config.name,
                    messageID: info.messageID,
                    author: senderID,
                    type: 'createCompany'
                });
            }, messageID);
        }
        
        case 'trangthai':
        case 'status': {
            if (!userData[userID]) {
                return api.sendMessage('üè¢ B·∫°n ch∆∞a c√≥ c√¥ng ty! D√πng "!dechete batdau" ƒë·ªÉ b·∫Øt ƒë·∫ßu.', threadID, messageID);
            }
            
            try {
                const imageBuffer = await createCompanyImage(userData[userID], companyStats);
                return api.sendMessage({
                    body: 'üè¢ Tr·∫°ng th√°i c√¥ng ty c·ªßa b·∫°n:',
                    attachment: imageBuffer
                }, threadID, messageID);
            } catch (error) {
                const user = userData[userID];
                const stats = companyStats[user.companyLevel];
                const message = `üè¢ ${user.companyName}\n\n` +
                    `üî∏ C·∫•p ƒë·ªô: Level ${user.companyLevel}\n` +
                    `üí∞ Ti·ªÅn m·∫∑t: $${formatMoney(user.cash)}\n` +
                    `üí≥ N·ª£: $${formatMoney(user.debt)}\n` +
                    `üíé T√†i s·∫£n th·ª±c: $${formatMoney(user.cash - user.debt)}\n` +
                    `‚ö° Thu nh·∫≠p/5p: $${formatMoney(stats.dailyPayout)}\n` +
                    `üîß Chi ph√≠ BT/ng√†y: $${formatMoney(stats.maintenanceCost)}\n` +
                    `‚ö†Ô∏è R·ªßi ro: ${user.riskFactor}%\n\n` +
                    `Credit: Kaori Waguri`;
                return api.sendMessage(message, threadID, messageID);
            }
        }
        
        case 'nangcap':
        case 'upgrade': {
            if (!userData[userID]) {
                return api.sendMessage('üè¢ B·∫°n ch∆∞a c√≥ c√¥ng ty! D√πng "!dechete batdau" ƒë·ªÉ b·∫Øt ƒë·∫ßu.', threadID, messageID);
            }
            
            const user = userData[userID];
            const nextLevel = user.companyLevel + 1;
            
            if (nextLevel > 10) {
                return api.sendMessage('üè¢ C√¥ng ty b·∫°n ƒë√£ ƒë·∫°t c·∫•p ƒë·ªô t·ªëi ƒëa!', threadID, messageID);
            }
            
            const upgradeCost = companyStats[nextLevel].upgradeCost;
            
            if (user.cash < upgradeCost) {
                return api.sendMessage(`üí∞ Kh√¥ng ƒë·ªß ti·ªÅn ƒë·ªÉ n√¢ng c·∫•p!\n\nC·∫ßn: $${formatMoney(upgradeCost)}\nHi·ªán c√≥: $${formatMoney(user.cash)}`, threadID, messageID);
            }
            
            user.cash -= upgradeCost;
            user.companyLevel = nextLevel;
            user.riskFactor = Math.max(0, user.riskFactor - 5); // Gi·∫£m r·ªßi ro khi n√¢ng c·∫•p
            
            saveData(dataPath, userData);
            updateLeaderboard(userID, user);
            
            return api.sendMessage(`üéâ N√ÇNG C·∫§P TH√ÄNH C√îNG!\n\nüè¢ ${user.companyName} ƒë√£ l√™n Level ${nextLevel}!\nüí∞ Chi ph√≠: $${formatMoney(upgradeCost)}\n‚ö° Thu nh·∫≠p m·ªõi: $${formatMoney(companyStats[nextLevel].dailyPayout)}/5p`, threadID, messageID);
        }
        
        case 'vayngan':
        case 'loan': {
            if (!userData[userID]) {
                return api.sendMessage('üè¢ B·∫°n ch∆∞a c√≥ c√¥ng ty! D√πng "!dechete batdau" ƒë·ªÉ b·∫Øt ƒë·∫ßu.', threadID, messageID);
            }
            
            const amount = parseInt(args[1]);
            if (!amount || amount <= 0) {
                return api.sendMessage('üí≥ Vui l√≤ng nh·∫≠p s·ªë ti·ªÅn mu·ªën vay!\nV√≠ d·ª•: !dechete vayngan 10000', threadID, messageID);
            }
            
            const user = userData[userID];
            const maxLoan = user.cash * 5; // T·ªëi ƒëa vay 5 l·∫ßn ti·ªÅn hi·ªán c√≥
            
            if (amount > maxLoan) {
                return api.sendMessage(`üí≥ S·ªë ti·ªÅn vay qu√° l·ªõn!\nT·ªëi ƒëa c√≥ th·ªÉ vay: $${formatMoney(maxLoan)}`, threadID, messageID);
            }
            
            const interest = Math.floor(amount * 0.2); // L√£i su·∫•t 20%
            user.cash += amount;
            user.debt += amount + interest;
            user.riskFactor += Math.floor(amount / 10000); // TƒÉng r·ªßi ro
            
            saveData(dataPath, userData);
            
            return api.sendMessage(`üí≥ VAY TH√ÄNH C√îNG!\n\nüí∞ Nh·∫≠n: $${formatMoney(amount)}\nüí∏ N·ª£ th√™m: $${formatMoney(amount + interest)}\n‚ö†Ô∏è R·ªßi ro tƒÉng: +${Math.floor(amount / 10000)}%`, threadID, messageID);
        }
        
        case 'trano':
        case 'repay': {
            if (!userData[userID]) {
                return api.sendMessage('üè¢ B·∫°n ch∆∞a c√≥ c√¥ng ty! D√πng "!dechete batdau" ƒë·ªÉ b·∫Øt ƒë·∫ßu.', threadID, messageID);
            }
            
            const amount = parseInt(args[1]);
            if (!amount || amount <= 0) {
                return api.sendMessage('üí≥ Vui l√≤ng nh·∫≠p s·ªë ti·ªÅn mu·ªën tr·∫£!\nV√≠ d·ª•: !dechete trano 10000', threadID, messageID);
            }
            
            const user = userData[userID];
            
            if (user.debt === 0) {
                return api.sendMessage('üí≥ B·∫°n kh√¥ng c√≥ n·ª£ n√†o c·∫ßn tr·∫£!', threadID, messageID);
            }
            
            if (user.cash < amount) {
                return api.sendMessage(`üí∞ Kh√¥ng ƒë·ªß ti·ªÅn!\nC·∫ßn: $${formatMoney(amount)}\nHi·ªán c√≥: $${formatMoney(user.cash)}`, threadID, messageID);
            }
            
            const actualPayment = Math.min(amount, user.debt);
            user.cash -= actualPayment;
            user.debt -= actualPayment;
            user.riskFactor = Math.max(0, user.riskFactor - Math.floor(actualPayment / 5000));
            
            saveData(dataPath, userData);
            
            return api.sendMessage(`üí≥ TR·∫¢ N·ª¢ TH√ÄNH C√îNG!\n\nüí∞ ƒê√£ tr·∫£: $${formatMoney(actualPayment)}\nüí∏ N·ª£ c√≤n l·∫°i: $${formatMoney(user.debt)}\n‚ö†Ô∏è R·ªßi ro gi·∫£m: -${Math.floor(actualPayment / 5000)}%`, threadID, messageID);
        }
        
        case 'bangxephang':
        case 'leaderboard': {
            const globalData = readData(globalDataPath);
            
            if (globalData.companies.length === 0) {
                return api.sendMessage('üìä Ch∆∞a c√≥ c√¥ng ty n√†o trong b·∫£ng x·∫øp h·∫°ng!', threadID, messageID);
            }
            
            let message = 'üèÜ B·∫¢NG X·∫æP H·∫†NG ƒê·∫æ CH·∫æ T√ÄI CH√çNH\n\n';
            
            for (let i = 0; i < Math.min(10, globalData.companies.length); i++) {
                const company = globalData.companies[i];
                const userName = await Users.getNameUser(company.userID) || 'Unknown';
                const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : `${i + 1}.`;
                
                message += `${medal} ${company.companyName}\n`;
                message += `   üë§ ${userName}\n`;
                message += `   üíé $${formatMoney(company.netWorth)} | Lv.${company.level}\n\n`;
            }
            
            message += 'Credit: Kaori Waguri';
            return api.sendMessage(message, threadID, messageID);
        }
        
        case 'dautus':
        case 'invest': {
            if (!userData[userID]) {
                return api.sendMessage('üè¢ B·∫°n ch∆∞a c√≥ c√¥ng ty! D√πng "!dechete batdau" ƒë·ªÉ b·∫Øt ƒë·∫ßu.', threadID, messageID);
            }
            
            const amount = parseInt(args[1]);
            if (!amount || amount <= 0) {
                return api.sendMessage('üìà Vui l√≤ng nh·∫≠p s·ªë ti·ªÅn mu·ªën ƒë·∫ßu t∆∞!\nV√≠ d·ª•: !dechete dautus 10000', threadID, messageID);
            }
            
            const user = userData[userID];
            
            if (user.cash < amount) {
                return api.sendMessage(`üí∞ Kh√¥ng ƒë·ªß ti·ªÅn ƒë·∫ßu t∆∞!\nC·∫ßn: $${formatMoney(amount)}\nHi·ªán c√≥: $${formatMoney(user.cash)}`, threadID, messageID);
            }
            
            const success = Math.random() > 0.5;
            const multiplier = success ? (1 + Math.random() * 0.8) : (0.2 + Math.random() * 0.6);
            const result = Math.floor(amount * multiplier);
            
            user.cash -= amount;
            user.cash += result;
            
            if (success) {
                user.riskFactor = Math.max(0, user.riskFactor - 2);
            } else {
                user.riskFactor += 3;
            }
            
            saveData(dataPath, userData);
            
            const profit = result - amount;
            const status = success ? 'üìà TH√ÄNH C√îNG' : 'üìâ TH·∫§T B·∫†I';
            const profitText = profit >= 0 ? `+$${formatMoney(profit)}` : `-$${formatMoney(Math.abs(profit))}`;
            
            return api.sendMessage(`${status}!\n\nüí∞ ƒê·∫ßu t∆∞: $${formatMoney(amount)}\nüíé Nh·∫≠n v·ªÅ: $${formatMoney(result)}\nüìä L√£i/l·ªó: ${profitText}`, threadID, messageID);
        }
        
        case 'banthuong':
        case 'market': {
            const market = [
                { name: 'üè≠ Nh√† m√°y s·∫£n xu·∫•t', price: 50000, income: 5000 },
                { name: 'üè¢ T√≤a nh√† vƒÉn ph√≤ng', price: 100000, income: 8000 },
                { name: 'üè™ Chu·ªói c·ª≠a h√†ng', price: 200000, income: 15000 },
                { name: '‚ö° Nh√† m√°y ƒëi·ªán', price: 500000, income: 35000 },
                { name: 'üõ¢Ô∏è Gi·∫øng d·∫ßu', price: 1000000, income: 70000 }
            ];
            
            let message = 'üè™ TH·ªä TR∆Ø·ªúNG B·∫§T ƒê·ªòNG S·∫¢N\n\n';
            market.forEach((item, index) => {
                message += `${index + 1}. ${item.name}\n`;
                message += `   üí∞ Gi√°: $${formatMoney(item.price)}\n`;
                message += `   üìà Thu nh·∫≠p: $${formatMoney(item.income)}/ng√†y\n\n`;
            });
            
            message += 'D√πng: !dechete muadatsan <s·ªë> ƒë·ªÉ mua';
            return api.sendMessage(message, threadID, messageID);
        }
        
        case 'admin_reset': {
            if (!global.config.ADMINBOT.includes(senderID)) {
                return api.sendMessage('‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!', threadID, messageID);
            }
            
            const target = args[1];
            if (!target) {
                return api.sendMessage('üîß C√∫ ph√°p: !dechete admin_reset <userID/all>', threadID, messageID);
            }
            
            if (target === 'all') {
                fs.writeFileSync(dataPath, JSON.stringify({}, null, 2));
                fs.writeFileSync(globalDataPath, JSON.stringify({ companies: [] }, null, 2));
                return api.sendMessage('üîß ƒê√£ reset to√†n b·ªô d·ªØ li·ªáu game!', threadID, messageID);
            } else {
                if (userData[target]) {
                    delete userData[target];
                    saveData(dataPath, userData);
                    return api.sendMessage(`üîß ƒê√£ reset d·ªØ li·ªáu c·ªßa user ${target}!`, threadID, messageID);
                } else {
                    return api.sendMessage('‚ùå User kh√¥ng t·ªìn t·∫°i trong h·ªá th·ªëng!', threadID, messageID);
                }
            }
        }
        
        case 'admin_add': {
            if (!global.config.ADMINBOT.includes(senderID)) {
                return api.sendMessage('‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!', threadID, messageID);
            }
            
            const target = args[1];
            const amount = parseInt(args[2]);
            
            if (!target || !amount) {
                return api.sendMessage('üîß C√∫ ph√°p: !dechete admin_add <userID> <amount>', threadID, messageID);
            }
            
            if (!userData[target]) {
                return api.sendMessage('‚ùå User ch∆∞a c√≥ c√¥ng ty!', threadID, messageID);
            }
            
            userData[target].cash += amount;
            saveData(dataPath, userData);
            
            return api.sendMessage(`üîß ƒê√£ th√™m $${formatMoney(amount)} cho ${target}!`, threadID, messageID);
        }
        
        default: {
            return api.sendMessage(`üè¢ ƒê·∫æ CH·∫æ T√ÄI CH√çNH üè¢
Credit: Kaori Waguri

üìã C√ÅC L·ªÜNH:
!dechete batdau - T·∫°o c√¥ng ty m·ªõi
!dechete trangthai - Xem tr·∫°ng th√°i c√¥ng ty
!dechete nangcap - N√¢ng c·∫•p c√¥ng ty
!dechete vayngan <s·ªë> - Vay ti·ªÅn
!dechete trano <s·ªë> - Tr·∫£ n·ª£
!dechete bangxephang - B·∫£ng x·∫øp h·∫°ng
!dechete dautus <s·ªë> - ƒê·∫ßu t∆∞ c·ªï phi·∫øu
!dechete banthuong - Th·ªã tr∆∞·ªùng BƒêS

‚ö° Thu nh·∫≠p t·ª± ƒë·ªông m·ªói 5 ph√∫t!
‚ö†Ô∏è Ch√∫ √Ω chi ph√≠ b·∫£o tr√¨ v√† r·ªßi ro ph√° s·∫£n!`, threadID, messageID);
        }
    }
};

module.exports.handleReply = async function({ api, event, handleReply, Users }) {
    const { threadID, messageID, senderID, body } = event;
    const { type, author } = handleReply;
    
    if (senderID !== author) return;
    
    if (type === 'createCompany') {
        if (!body || body.length < 3) {
            return api.sendMessage('‚ùå T√™n c√¥ng ty ph·∫£i c√≥ √≠t nh·∫•t 3 k√Ω t·ª±!', threadID, messageID);
        }
        
        if (body.length > 30) {
            return api.sendMessage('‚ùå T√™n c√¥ng ty kh√¥ng ƒë∆∞·ª£c qu√° 30 k√Ω t·ª±!', threadID, messageID);
        }
        
        const userData = readData(dataPath);
        
        // Ki·ªÉm tra t√™n tr√πng
        const existingNames = Object.values(userData).map(u => u.companyName.toLowerCase());
        if (existingNames.includes(body.toLowerCase())) {
            return api.sendMessage('‚ùå T√™n c√¥ng ty ƒë√£ t·ªìn t·∫°i! Vui l√≤ng ch·ªçn t√™n kh√°c.', threadID, messageID);
        }
        
        userData[senderID] = {
            companyName: body,
            cash: 10000,
            debt: 0,
            companyLevel: 1,
            lastPayout: Date.now(),
            riskFactor: 0
        };
        
        saveData(dataPath, userData);
        updateLeaderboard(senderID, userData[senderID]);
        
        return api.sendMessage(`üéâ CH√öC M·ª™NG!\n\nüè¢ C√¥ng ty "${body}" ƒë√£ ƒë∆∞·ª£c th√†nh l·∫≠p!\nüí∞ V·ªën ban ƒë·∫ßu: $10,000\n‚ö° Thu nh·∫≠p: $1,000/5p\n\nCh√∫c b·∫°n x√¢y d·ª±ng ƒë·∫ø ch·∫ø th√†nh c√¥ng!`, threadID, messageID);
    }
};
