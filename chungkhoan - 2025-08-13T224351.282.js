
const fs = require('fs-extra');
const path = require('path');
const axios = require('axios');
const { createCanvas, loadImage, registerFont } = require('canvas');

module.exports.config = {
    name: "chungkhoan",
    version: "1.0.0", 
    hasPermssion: 0,
    credits: "DeepSeek AI Stock System",
    description: "H·ªá th·ªëng ch·ª©ng kho√°n ·∫£o v·ªõi AI DeepSeek",
    commandCategory: "T√†i ch√≠nh",
    usages: "[mua/ban/xem/top/thitruong/lichsu]",
    cooldowns: 3,
    dependencies: {
        "canvas": "",
        "axios": ""
    }
};

// DeepSeek API configuration
const DEEPSEEK_API_KEY = "sk-eb7832d105d949bf8821a49614ea6004";
const DEEPSEEK_API_URL = "https://api.deepseek.com/v1/chat/completions";

// Kh·ªüi t·∫°o d·ªØ li·ªáu th·ªã tr∆∞·ªùng
const initMarketData = () => {
    return {
        stocks: {
            "MIRAI": { name: "Mirai Corp", price: 100, change: 0, volume: 1000, sector: "Tech" },
            "BOTCOIN": { name: "Bot Coin Ltd", price: 50, change: 0, volume: 800, sector: "Crypto" },
            "AICORP": { name: "AI Corporation", price: 150, change: 0, volume: 1200, sector: "AI" },
            "TECHVN": { name: "Tech Vietnam", price: 75, change: 0, volume: 900, sector: "Tech" },
            "GAMEVN": { name: "Game Vietnam", price: 25, change: 0, volume: 600, sector: "Gaming" },
            "SOCIALNET": { name: "Social Network Co", price: 120, change: 0, volume: 1100, sector: "Social" }
        },
        marketTrend: "stable",
        lastUpdate: Date.now(),
        dailyNews: []
    };
};

// G·ªçi DeepSeek API
async function callDeepSeekAPI(prompt) {
    try {
        const response = await axios.post(DEEPSEEK_API_URL, {
            model: "deepseek-chat",
            messages: [{
                role: "user",
                content: prompt
            }],
            temperature: 0.7,
            max_tokens: 500
        }, {
            headers: {
                'Authorization': `Bearer ${DEEPSEEK_API_KEY}`,
                'Content-Type': 'application/json'
            }
        });

        return response.data.choices[0].message.content;
    } catch (error) {
        console.error("DeepSeek API Error:", error.response?.data || error.message);
        return null;
    }
}

// C·∫≠p nh·∫≠t th·ªã tr∆∞·ªùng v·ªõi AI
async function updateMarketWithAI(marketData) {
    const prompt = `
    B·∫°n l√† m·ªôt chuy√™n gia th·ªã tr∆∞·ªùng ch·ª©ng kho√°n. H√£y c·∫≠p nh·∫≠t gi√° c√°c c·ªï phi·∫øu sau d·ª±a tr√™n xu h∆∞·ªõng th·ªã tr∆∞·ªùng hi·ªán t·∫°i.
    
    Danh s√°ch c·ªï phi·∫øu:
    ${Object.entries(marketData.stocks).map(([symbol, data]) => 
        `${symbol}: ${data.name} - Gi√° hi·ªán t·∫°i: ${data.price} - Ng√†nh: ${data.sector}`
    ).join('\n')}
    
    Xu h∆∞·ªõng th·ªã tr∆∞·ªùng hi·ªán t·∫°i: ${marketData.marketTrend}
    
    H√£y tr·∫£ v·ªÅ d·ªØ li·ªáu JSON v·ªõi format:
    {
        "updates": {
            "SYMBOL": {"price": number, "change": number},
            ...
        },
        "marketTrend": "bull|bear|stable",
        "news": "Tin t·ª©c th·ªã tr∆∞·ªùng ng·∫Øn g·ªçn"
    }
    
    Thay ƒë·ªïi gi√° n√™n h·ª£p l√Ω, kh√¥ng qu√° 10% m·ªói l·∫ßn c·∫≠p nh·∫≠t.
    `;

    const aiResponse = await callDeepSeekAPI(prompt);
    if (!aiResponse) return marketData;

    try {
        const aiData = JSON.parse(aiResponse);
        
        // C·∫≠p nh·∫≠t gi√° c·ªï phi·∫øu
        if (aiData.updates) {
            for (const [symbol, update] of Object.entries(aiData.updates)) {
                if (marketData.stocks[symbol]) {
                    const oldPrice = marketData.stocks[symbol].price;
                    marketData.stocks[symbol].price = Math.max(1, update.price);
                    marketData.stocks[symbol].change = ((marketData.stocks[symbol].price - oldPrice) / oldPrice * 100);
                    marketData.stocks[symbol].volume += Math.floor(Math.random() * 200) - 100;
                }
            }
        }

        // C·∫≠p nh·∫≠t xu h∆∞·ªõng th·ªã tr∆∞·ªùng
        if (aiData.marketTrend) {
            marketData.marketTrend = aiData.marketTrend;
        }

        // Th√™m tin t·ª©c
        if (aiData.news) {
            marketData.dailyNews.unshift({
                content: aiData.news,
                time: new Date().toLocaleTimeString('vi-VN')
            });
            if (marketData.dailyNews.length > 5) {
                marketData.dailyNews = marketData.dailyNews.slice(0, 5);
            }
        }

        marketData.lastUpdate = Date.now();
        return marketData;
    } catch (error) {
        console.error("Error parsing AI response:", error);
        return marketData;
    }
}

// T·∫°o bi·ªÉu ƒë·ªì th·ªã tr∆∞·ªùng
async function createMarketChart(marketData, userPortfolio = null) {
    const canvas = createCanvas(800, 600);
    const ctx = canvas.getContext('2d');

    // Background gradient
    const gradient = ctx.createLinearGradient(0, 0, 0, 600);
    gradient.addColorStop(0, '#0a0e1a');
    gradient.addColorStop(1, '#1a1f36');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 800, 600);

    // Header
    ctx.fillStyle = '#00d4ff';
    ctx.font = 'bold 28px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('üèõÔ∏è MIRAI STOCK MARKET üèõÔ∏è', 400, 40);

    // Market trend indicator
    const trendColor = marketData.marketTrend === 'bull' ? '#00ff88' : 
                      marketData.marketTrend === 'bear' ? '#ff4757' : '#ffa502';
    const trendText = marketData.marketTrend === 'bull' ? 'üìà TƒÇNG' : 
                     marketData.marketTrend === 'bear' ? 'üìâ GI·∫¢M' : 'üìä ·ªîN ƒê·ªäNH';
    
    ctx.fillStyle = trendColor;
    ctx.font = 'bold 16px Arial';
    ctx.fillText(`Xu h∆∞·ªõng: ${trendText}`, 400, 70);

    // Stock list header
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('M√£ CK', 50, 120);
    ctx.fillText('T√™n c√¥ng ty', 150, 120);
    ctx.fillText('Gi√°', 350, 120);
    ctx.fillText('Thay ƒë·ªïi', 450, 120);
    ctx.fillText('Kh·ªëi l∆∞·ª£ng', 580, 120);

    // Draw line separator
    ctx.strokeStyle = '#3c4560';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(30, 135);
    ctx.lineTo(770, 135);
    ctx.stroke();

    // Stock list
    let y = 165;
    Object.entries(marketData.stocks).forEach(([symbol, stock], index) => {
        const changeColor = stock.change > 0 ? '#00ff88' : stock.change < 0 ? '#ff4757' : '#ffa502';
        const changeText = stock.change > 0 ? '+' + stock.change.toFixed(2) + '%' : stock.change.toFixed(2) + '%';
        
        // Alternating row background
        if (index % 2 === 0) {
            ctx.fillStyle = 'rgba(60, 69, 96, 0.3)';
            ctx.fillRect(30, y - 20, 740, 35);
        }

        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 14px Arial';
        ctx.fillText(symbol, 50, y);
        
        ctx.fillStyle = '#c5c9d6';
        ctx.font = '12px Arial';
        ctx.fillText(stock.name, 150, y);
        
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 14px Arial';
        ctx.fillText(stock.price.toLocaleString() + ' BAO', 350, y);
        
        ctx.fillStyle = changeColor;
        ctx.fillText(changeText, 450, y);
        
        ctx.fillStyle = '#c5c9d6';
        ctx.font = '12px Arial';
        ctx.fillText(stock.volume.toLocaleString(), 580, y);

        y += 40;
    });

    // Portfolio section (n·∫øu c√≥)
    if (userPortfolio && Object.keys(userPortfolio.stocks || {}).length > 0) {
        y += 20;
        ctx.fillStyle = '#00d4ff';
        ctx.font = 'bold 16px Arial';
        ctx.fillText('üìä Danh m·ª•c c·ªßa b·∫°n:', 50, y);
        
        y += 25;
        let totalValue = 0;
        Object.entries(userPortfolio.stocks).forEach(([symbol, shares]) => {
            if (marketData.stocks[symbol]) {
                const value = shares * marketData.stocks[symbol].price;
                totalValue += value;
                
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Arial';
                ctx.fillText(`${symbol}: ${shares} c·ªï phi·∫øu √ó ${marketData.stocks[symbol].price} = ${value.toLocaleString()} BAO`, 70, y);
                y += 20;
            }
        });
        
        ctx.fillStyle = '#00ff88';
        ctx.font = 'bold 14px Arial';
        ctx.fillText(`üí∞ T·ªïng gi√° tr·ªã: ${totalValue.toLocaleString()} BAO`, 50, y + 10);
    }

    // News section
    if (marketData.dailyNews.length > 0) {
        ctx.fillStyle = '#ffa502';
        ctx.font = 'bold 14px Arial';
        ctx.fillText('üì∞ Tin t·ª©c th·ªã tr∆∞·ªùng:', 50, 520);
        
        ctx.fillStyle = '#c5c9d6';
        ctx.font = '11px Arial';
        const newsText = marketData.dailyNews[0].content;
        const words = newsText.split(' ');
        let line = '';
        let y = 545;
        
        for (const word of words) {
            const testLine = line + word + ' ';
            const metrics = ctx.measureText(testLine);
            if (metrics.width > 700 && line !== '') {
                ctx.fillText(line, 50, y);
                line = word + ' ';
                y += 15;
            } else {
                line = testLine;
            }
        }
        if (line !== '') {
            ctx.fillText(line, 50, y);
        }
    }

    // Footer
    ctx.fillStyle = '#576574';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`C·∫≠p nh·∫≠t l·∫ßn cu·ªëi: ${new Date(marketData.lastUpdate).toLocaleString('vi-VN')} | Powered by DeepSeek AI`, 400, 590);

    return canvas.toBuffer();
}

// L∆∞u/ƒê·ªçc d·ªØ li·ªáu
const dataPath = path.join(__dirname, 'cache', 'chungkhoan');
const marketFile = path.join(dataPath, 'market.json');
const usersFile = path.join(dataPath, 'users.json');

async function loadMarketData() {
    if (!fs.existsSync(dataPath)) {
        await fs.mkdirs(dataPath);
    }
    
    if (fs.existsSync(marketFile)) {
        return JSON.parse(await fs.readFile(marketFile, 'utf8'));
    } else {
        const initialData = initMarketData();
        await fs.writeFile(marketFile, JSON.stringify(initialData, null, 2));
        return initialData;
    }
}

async function saveMarketData(data) {
    await fs.writeFile(marketFile, JSON.stringify(data, null, 2));
}

async function loadUserData() {
    if (fs.existsSync(usersFile)) {
        return JSON.parse(await fs.readFile(usersFile, 'utf8'));
    }
    return {};
}

async function saveUserData(data) {
    await fs.writeFile(usersFile, JSON.stringify(data, null, 2));
}

// Auto update th·ªã tr∆∞·ªùng (ch·∫°y m·ªói 10 ph√∫t)
let autoUpdateInterval;
async function startAutoUpdate(api) {
    if (autoUpdateInterval) return;
    
    autoUpdateInterval = setInterval(async () => {
        try {
            let marketData = await loadMarketData();
            marketData = await updateMarketWithAI(marketData);
            await saveMarketData(marketData);
            
            // Th√¥ng b√°o cho c√°c nh√≥m ƒë√£ b·∫≠t auto notify
            const userData = await loadUserData();
            const chartBuffer = await createMarketChart(marketData);
            
            for (const [threadID, data] of Object.entries(userData)) {
                if (data.autoNotify) {
                    api.sendMessage({
                        body: `üîî C·∫¨P NH·∫¨T TH·ªä TR∆Ø·ªúNG T·ª∞ ƒê·ªòNG\n\nüìà Xu h∆∞·ªõng: ${marketData.marketTrend.toUpperCase()}\nüïê ${new Date().toLocaleTimeString('vi-VN')}\n\nüí° S·ª≠ d·ª•ng "chungkhoan xem" ƒë·ªÉ xem chi ti·∫øt!`,
                        attachment: fs.createReadStream(path.join(dataPath, 'temp_chart.png'))
                    }, threadID);
                }
            }
            
            // L∆∞u chart t·∫°m
            await fs.writeFile(path.join(dataPath, 'temp_chart.png'), chartBuffer);
            
        } catch (error) {
            console.error("Auto update error:", error);
        }
    }, 10 * 60 * 1000); // 10 ph√∫t
}

module.exports.run = async function({ api, event, args, Currencies, Users }) {
    const { threadID, messageID, senderID } = event;
    
    // Start auto update n·∫øu ch∆∞a ch·∫°y
    startAutoUpdate(api);
    
    if (!args[0]) {
        return api.sendMessage(`üèõÔ∏è H·ªÜ TH·ªêNG CH·ª®NG KHO√ÅN MIRAI\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nüìä L·ªÜNH C∆† B·∫¢N:\n‚Ä¢ chungkhoan xem - Xem th·ªã tr∆∞·ªùng\n‚Ä¢ chungkhoan mua [m√£] [s·ªë l∆∞·ª£ng] - Mua c·ªï phi·∫øu\n‚Ä¢ chungkhoan ban [m√£] [s·ªë l∆∞·ª£ng] - B√°n c·ªï phi·∫øu\n‚Ä¢ chungkhoan lichsu - Xem l·ªãch s·ª≠ giao d·ªãch\n\nüéØ L·ªÜNH N√ÇNG CAO:\n‚Ä¢ chungkhoan top - Xem top nh√† ƒë·∫ßu t∆∞\n‚Ä¢ chungkhoan auto [on/off] - B·∫≠t/t·∫Øt th√¥ng b√°o t·ª± ƒë·ªông\n‚Ä¢ chungkhoan ai [c√¢u h·ªèi] - T∆∞ v·∫•n t·ª´ AI\n\nüí° H·ªá th·ªëng ƒë∆∞·ª£c v·∫≠n h√†nh b·ªüi DeepSeek AI`, threadID, messageID);
    }

    let marketData = await loadMarketData();
    let userData = await loadUserData();

    // Kh·ªüi t·∫°o d·ªØ li·ªáu user n·∫øu ch∆∞a c√≥
    if (!userData[threadID]) {
        userData[threadID] = {
            users: {},
            autoNotify: false
        };
    }

    if (!userData[threadID].users[senderID]) {
        userData[threadID].users[senderID] = {
            stocks: {},
            transactions: [],
            totalInvested: 0,
            totalValue: 0
        };
    }

    const command = args[0].toLowerCase();

    switch (command) {
        case 'xem':
        case 'thitruong':
            // C·∫≠p nh·∫≠t th·ªã tr∆∞·ªùng tr∆∞·ªõc khi hi·ªÉn th·ªã
            marketData = await updateMarketWithAI(marketData);
            await saveMarketData(marketData);

            const userPortfolio = userData[threadID].users[senderID];
            const chartBuffer = await createMarketChart(marketData, userPortfolio);
            const chartPath = path.join(dataPath, `chart_${threadID}_${Date.now()}.png`);
            await fs.writeFile(chartPath, chartBuffer);

            api.sendMessage({
                body: `üèõÔ∏è TH·ªä TR∆Ø·ªúNG CH·ª®NG KHO√ÅN MIRAI\n\nüìà Xu h∆∞·ªõng: ${marketData.marketTrend.toUpperCase()}\nüïê C·∫≠p nh·∫≠t: ${new Date().toLocaleTimeString('vi-VN')}\n\nüí° S·ª≠ d·ª•ng "chungkhoan mua [m√£] [s·ªë l∆∞·ª£ng]" ƒë·ªÉ ƒë·∫ßu t∆∞!`,
                attachment: fs.createReadStream(chartPath)
            }, threadID, () => fs.unlink(chartPath), messageID);
            break;

        case 'mua':
            if (!args[1] || !args[2]) {
                return api.sendMessage("‚ùå S·ª≠ d·ª•ng: chungkhoan mua [m√£ c·ªï phi·∫øu] [s·ªë l∆∞·ª£ng]\nV√≠ d·ª•: chungkhoan mua MIRAI 10", threadID, messageID);
            }

            const buySymbol = args[1].toUpperCase();
            const buyQuantity = parseInt(args[2]);

            if (!marketData.stocks[buySymbol]) {
                return api.sendMessage(`‚ùå Kh√¥ng t√¨m th·∫•y m√£ c·ªï phi·∫øu "${buySymbol}"\nC√°c m√£ c√≥ s·∫µn: ${Object.keys(marketData.stocks).join(', ')}`, threadID, messageID);
            }

            if (buyQuantity <= 0) {
                return api.sendMessage("‚ùå S·ªë l∆∞·ª£ng mua ph·∫£i l·ªõn h∆°n 0!", threadID, messageID);
            }

            const buyPrice = marketData.stocks[buySymbol].price;
            const totalCost = buyPrice * buyQuantity;
            const userMoney = (await Currencies.getData(senderID)).money;

            if (userMoney < totalCost) {
                return api.sendMessage(`‚ùå Kh√¥ng ƒë·ªß ti·ªÅn!\nC·∫ßn: ${totalCost.toLocaleString()} BAO\nC√≥: ${userMoney.toLocaleString()} BAO\nThi·∫øu: ${(totalCost - userMoney).toLocaleString()} BAO`, threadID, messageID);
            }

            // Th·ª±c hi·ªán giao d·ªãch
            await Currencies.decreaseMoney(senderID, totalCost);
            
            if (!userData[threadID].users[senderID].stocks[buySymbol]) {
                userData[threadID].users[senderID].stocks[buySymbol] = 0;
            }
            userData[threadID].users[senderID].stocks[buySymbol] += buyQuantity;
            userData[threadID].users[senderID].totalInvested += totalCost;
            
            // L∆∞u l·ªãch s·ª≠ giao d·ªãch
            userData[threadID].users[senderID].transactions.push({
                type: 'BUY',
                symbol: buySymbol,
                quantity: buyQuantity,
                price: buyPrice,
                total: totalCost,
                time: new Date().toLocaleString('vi-VN')
            });

            await saveUserData(userData);

            api.sendMessage(`‚úÖ MUA TH√ÄNH C√îNG!\n\nüè∑Ô∏è M√£: ${buySymbol}\nüìä S·ªë l∆∞·ª£ng: ${buyQuantity} c·ªï phi·∫øu\nüí∞ Gi√°: ${buyPrice.toLocaleString()} BAO/c·ªï phi·∫øu\nüí∏ T·ªïng ti·ªÅn: ${totalCost.toLocaleString()} BAO\n\nüìà B·∫°n ƒëang s·ªü h·ªØu ${userData[threadID].users[senderID].stocks[buySymbol]} c·ªï phi·∫øu ${buySymbol}`, threadID, messageID);
            break;

        case 'ban':
            if (!args[1] || !args[2]) {
                return api.sendMessage("‚ùå S·ª≠ d·ª•ng: chungkhoan ban [m√£ c·ªï phi·∫øu] [s·ªë l∆∞·ª£ng]\nV√≠ d·ª•: chungkhoan ban MIRAI 5", threadID, messageID);
            }

            const sellSymbol = args[1].toUpperCase();
            const sellQuantity = parseInt(args[2]);

            if (!marketData.stocks[sellSymbol]) {
                return api.sendMessage(`‚ùå Kh√¥ng t√¨m th·∫•y m√£ c·ªï phi·∫øu "${sellSymbol}"`, threadID, messageID);
            }

            if (!userData[threadID].users[senderID].stocks[sellSymbol] || userData[threadID].users[senderID].stocks[sellSymbol] < sellQuantity) {
                const owned = userData[threadID].users[senderID].stocks[sellSymbol] || 0;
                return api.sendMessage(`‚ùå Kh√¥ng ƒë·ªß c·ªï phi·∫øu ƒë·ªÉ b√°n!\nB·∫°n c√≥: ${owned} c·ªï phi·∫øu ${sellSymbol}\nMu·ªën b√°n: ${sellQuantity} c·ªï phi·∫øu`, threadID, messageID);
            }

            const sellPrice = marketData.stocks[sellSymbol].price;
            const totalRevenue = sellPrice * sellQuantity;

            // Th·ª±c hi·ªán b√°n
            await Currencies.increaseMoney(senderID, totalRevenue);
            userData[threadID].users[senderID].stocks[sellSymbol] -= sellQuantity;
            
            if (userData[threadID].users[senderID].stocks[sellSymbol] === 0) {
                delete userData[threadID].users[senderID].stocks[sellSymbol];
            }

            // L∆∞u l·ªãch s·ª≠ giao d·ªãch
            userData[threadID].users[senderID].transactions.push({
                type: 'SELL',
                symbol: sellSymbol,
                quantity: sellQuantity,
                price: sellPrice,
                total: totalRevenue,
                time: new Date().toLocaleString('vi-VN')
            });

            await saveUserData(userData);

            api.sendMessage(`‚úÖ B√ÅN TH√ÄNH C√îNG!\n\nüè∑Ô∏è M√£: ${sellSymbol}\nüìä S·ªë l∆∞·ª£ng: ${sellQuantity} c·ªï phi·∫øu\nüí∞ Gi√°: ${sellPrice.toLocaleString()} BAO/c·ªï phi·∫øu\nüíµ T·ªïng ti·ªÅn nh·∫≠n: ${totalRevenue.toLocaleString()} BAO\n\nüìä C√≤n l·∫°i: ${userData[threadID].users[senderID].stocks[sellSymbol] || 0} c·ªï phi·∫øu ${sellSymbol}`, threadID, messageID);
            break;

        case 'lichsu':
            const userTransactions = userData[threadID].users[senderID].transactions || [];
            
            if (userTransactions.length === 0) {
                return api.sendMessage("üìù B·∫°n ch∆∞a c√≥ giao d·ªãch n√†o!", threadID, messageID);
            }

            let historyMsg = `üìä L·ªäCH S·ª¨ GIAO D·ªäCH\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
            const recentTransactions = userTransactions.slice(-10); // 10 giao d·ªãch g·∫ßn nh·∫•t

            recentTransactions.forEach((trans, index) => {
                const icon = trans.type === 'BUY' ? 'üü¢' : 'üî¥';
                const action = trans.type === 'BUY' ? 'MUA' : 'B√ÅN';
                historyMsg += `${icon} ${action} ${trans.symbol}\n`;
                historyMsg += `   ‚îî ${trans.quantity} c·ªï phi·∫øu √ó ${trans.price} = ${trans.total.toLocaleString()} BAO\n`;
                historyMsg += `   ‚îî ${trans.time}\n\n`;
            });

            if (userTransactions.length > 10) {
                historyMsg += `üìù Hi·ªÉn th·ªã 10/${userTransactions.length} giao d·ªãch g·∫ßn nh·∫•t`;
            }

            api.sendMessage(historyMsg, threadID, messageID);
            break;

        case 'top':
            // T√≠nh to√°n top nh√† ƒë·∫ßu t∆∞
            let investors = [];
            
            for (const [tid, threadData] of Object.entries(userData)) {
                for (const [uid, user] of Object.entries(threadData.users)) {
                    let totalValue = 0;
                    for (const [symbol, shares] of Object.entries(user.stocks)) {
                        if (marketData.stocks[symbol]) {
                            totalValue += shares * marketData.stocks[symbol].price;
                        }
                    }
                    
                    if (totalValue > 0) {
                        investors.push({
                            userID: uid,
                            threadID: tid,
                            totalValue,
                            totalInvested: user.totalInvested || 0
                        });
                    }
                }
            }

            investors.sort((a, b) => b.totalValue - a.totalValue);
            
            let topMsg = `üèÜ TOP NH√Ä ƒê·∫¶U T∆Ø\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
            
            for (let i = 0; i < Math.min(10, investors.length); i++) {
                const investor = investors[i];
                const userName = await Users.getNameUser(investor.userID) || "Unknown";
                const rank = i + 1;
                const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `${rank}.`;
                
                topMsg += `${medal} ${userName}\n`;
                topMsg += `   üí∞ Gi√° tr·ªã danh m·ª•c: ${investor.totalValue.toLocaleString()} BAO\n`;
                topMsg += `   üìä ƒê√£ ƒë·∫ßu t∆∞: ${investor.totalInvested.toLocaleString()} BAO\n\n`;
            }

            api.sendMessage(topMsg, threadID, messageID);
            break;

        case 'auto':
            if (!args[1] || !['on', 'off'].includes(args[1].toLowerCase())) {
                return api.sendMessage("‚ùå S·ª≠ d·ª•ng: chungkhoan auto [on/off]", threadID, messageID);
            }

            const autoMode = args[1].toLowerCase() === 'on';
            userData[threadID].autoNotify = autoMode;
            await saveUserData(userData);

            api.sendMessage(`${autoMode ? '‚úÖ' : '‚ùå'} ƒê√£ ${autoMode ? 'B·∫¨T' : 'T·∫ÆT'} th√¥ng b√°o t·ª± ƒë·ªông c·∫≠p nh·∫≠t th·ªã tr∆∞·ªùng!${autoMode ? '\n\nüîî Bot s·∫Ω g·ª≠i c·∫≠p nh·∫≠t th·ªã tr∆∞·ªùng m·ªói 10 ph√∫t' : ''}`, threadID, messageID);
            break;

        case 'ai':
            if (!args[1]) {
                return api.sendMessage("‚ùå H√£y ƒë·∫∑t c√¢u h·ªèi cho AI!\nV√≠ d·ª•: chungkhoan ai n√™n mua c·ªï phi·∫øu n√†o?", threadID, messageID);
            }

            const question = args.slice(1).join(' ');
            const aiPrompt = `
            B·∫°n l√† m·ªôt chuy√™n gia t∆∞ v·∫•n ƒë·∫ßu t∆∞ ch·ª©ng kho√°n. H√£y tr·∫£ l·ªùi c√¢u h·ªèi sau d·ª±a tr√™n d·ªØ li·ªáu th·ªã tr∆∞·ªùng hi·ªán t·∫°i:

            C√¢u h·ªèi: ${question}

            D·ªØ li·ªáu th·ªã tr∆∞·ªùng:
            ${Object.entries(marketData.stocks).map(([symbol, data]) => 
                `${symbol}: ${data.name} - Gi√°: ${data.price} BAO - Thay ƒë·ªïi: ${data.change.toFixed(2)}% - Ng√†nh: ${data.sector}`
            ).join('\n')}

            Xu h∆∞·ªõng th·ªã tr∆∞·ªùng: ${marketData.marketTrend}

            H√£y ƒë∆∞a ra l·ªùi khuy√™n ng·∫Øn g·ªçn, d·ªÖ hi·ªÉu (kh√¥ng qu√° 300 t·ª´).
            `;

            api.sendMessage("ü§ñ AI ƒëang ph√¢n t√≠ch... Vui l√≤ng ƒë·ª£i!", threadID, messageID);

            const aiAdvice = await callDeepSeekAPI(aiPrompt);
            if (aiAdvice) {
                api.sendMessage(`ü§ñ T∆Ø V·∫§N T·ª™ AI DEEPSEEK:\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n${aiAdvice}\n\nüí° L∆∞u √Ω: ƒê√¢y ch·ªâ l√† t∆∞ v·∫•n tham kh·∫£o. Quy·∫øt ƒë·ªãnh ƒë·∫ßu t∆∞ l√† do b·∫°n!`, threadID);
            } else {
                api.sendMessage("‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi v·ªõi AI. Vui l√≤ng th·ª≠ l·∫°i sau!", threadID, messageID);
            }
            break;

        default:
            api.sendMessage("‚ùå L·ªánh kh√¥ng h·ª£p l·ªá! S·ª≠ d·ª•ng 'chungkhoan' ƒë·ªÉ xem h∆∞·ªõng d·∫´n.", threadID, messageID);
    }
};

module.exports.handleEvent = async function({ api, event }) {
    // Auto start khi module ƒë∆∞·ª£c load
    if (!autoUpdateInterval) {
        startAutoUpdate(api);
    }
};

module.exports.onLoad = function() {
    console.log("üìà Module ch·ª©ng kho√°n v·ªõi DeepSeek AI ƒë√£ ƒë∆∞·ª£c t·∫£i!");
    
    // Kh·ªüi t·∫°o th∆∞ m·ª•c cache
    const dataPath = path.join(__dirname, 'cache', 'chungkhoan');
    if (!fs.existsSync(dataPath)) {
        fs.mkdirsSync(dataPath);
    }
};
